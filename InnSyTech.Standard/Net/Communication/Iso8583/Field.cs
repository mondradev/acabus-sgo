///////////////////////////////////////////////////////////
// FieldIso8583.cs Implementation of the Class FieldIso8583 Generated by Enterprise Architect Created
// on: 12-dic.-2017 06:17:16 p. m. Original author: Javier de J. Flores Mondragón
///////////////////////////////////////////////////////////

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;

namespace InnSyTech.Standard.Net.Communication.Iso8583
{
    /// <summary>
    /// Representa un campo utilizado para los mensajes de transacciones financieras del ISO 8583.
    /// </summary>
    public sealed class Field
    {
        /// <summary>
        /// Campo que provee a la propiedad <see cref="ID" />.
        /// </summary>
        private int _id;

        /// <summary>
        /// Campo que provee a la propiedad <see cref="Value" />.
        /// </summary>
        private object _value;

        /// <summary>
        /// Crea un nuevo campo especificando su identificador y el valor.
        /// </summary>
        /// <param name="id"> Identificador del campo. </param>
        /// <param name="value"> Valor del campo. </param>
        public Field(int id, object value)
        {
            _id = id;
            _value = value;
        }

        /// <summary>
        /// Destruye el campo estableciendo su identificar en 0 y su valor en nulo.
        /// </summary>
        ~Field()
        {
            _id = 0;
            _value = null;
        }

        /// <summary>
        /// Obtiene el identificador del campo.
        /// </summary>
        public int ID
            => _id;

        /// <summary>
        /// Obtiene el valor del campo.
        /// </summary>
        public object Value
            => _value;

        /// <summary>
        /// Decodifica el campo a partir de un vector de bytes especficando el tipo del campo y su longitud.
        /// </summary>
        /// <param name="id">Identificador del campo.</param>
        /// <param name="data"> Vector de bytes que representan al campo. </param>
        /// <param name="size"> Longitud máxima o fija del campo según el tipo. </param>
        /// <param name="type"> Tipo del campo a decodificar. </param>
        /// <param name="length"> Tipo de longitud del campo. </param>
        /// <param name="format"> Formato de contenido del campo. </param>
        /// <returns> El campo decodificado. </returns>
        public static Field Decode(int id, ref byte[] data, int size, FieldType type, FieldLength length = FieldLength.Fixed,
            FieldFormat format = FieldFormat.Hexadecimal)
        {
            int minSize = size;

            switch (length)
            {
                case FieldLength.Fixed:
                    minSize = size;
                    break;

                case FieldLength.Lvar:
                    minSize = 2;
                    break;

                case FieldLength.Llvar:
                    minSize = (format & FieldFormat.BinaryCodedDecimal) == FieldFormat.BinaryCodedDecimal ? 2 : 3;
                    break;

                case FieldLength.Lllvar:
                    minSize = (format & FieldFormat.BinaryCodedDecimal) == FieldFormat.BinaryCodedDecimal ? 3 : 4;
                    break;

                default:
                    throw new ArgumentOutOfRangeException(nameof(length), "El tipo de longitud del campo no es valida para los mensajes ISO8583.");
            }

            switch (format)
            {
                case FieldFormat.Hexadecimal:
                    break;

                case FieldFormat.BinaryCodedDecimal:
                    if (type == FieldType.Special)
                        throw new ArgumentOutOfRangeException(nameof(format), "El formato no es compatible con el tipo especificado para los mensajes ISO8583.");
                    break;

                default:
                    throw new ArgumentOutOfRangeException(nameof(format), "El formato del campo no es valido para los mensajes ISO8583.");
            }

            switch (type)
            {
                case FieldType.Numeric:

                    /** Convesión de un campo numérico **/

                    if (format == FieldFormat.BinaryCodedDecimal)
                    {
                        if (length == FieldLength.Fixed)
                        {
                            int numeric = Int32.Parse(BitConverter.ToString(data.Take(size).ToArray()).Replace("-", ""));

                            data = data.Skip(size).ToArray();

                            return new Field(id, numeric);
                        }
                        else
                        {
                            byte[] vli = data.Take(minSize - 1).ToArray();
                            int realSize = GetSize(vli, FieldFormat.BinaryCodedDecimal);
                            int nBytes = (realSize / 2) % 2 == 0 ? realSize / 2 : realSize / 2 + 1;
                            nBytes = nBytes == 0 ? nBytes + 1 : nBytes;
                            int numeric = Int32.Parse(BitConverter.ToString(data.Skip(minSize - 1).Take(nBytes).ToArray()).Replace("-", ""));

                            data = data.Skip(minSize - 1 + nBytes).ToArray();

                            return new Field(id, numeric);
                        }
                    }
                    else if ((format & FieldFormat.Hexadecimal) == FieldFormat.Hexadecimal)
                    {
                        if (length == FieldLength.Fixed)
                        {
                            int numeric = Int32.Parse(Encoding.ASCII.GetString(data.Take(size).ToArray()));

                            data = data.Skip(size).ToArray();

                            return new Field(id, numeric);
                        }
                        else
                        {
                            byte[] vli = data.Take(minSize - 1).ToArray();
                            int realSize = GetSize(vli, format);
                            int numeric = Int32.Parse(Encoding.ASCII.GetString(data.Skip(minSize - 1).Take(realSize).ToArray()));

                            data = data.Skip(minSize - 1 + realSize).ToArray();

                            return new Field(id, numeric);
                        }
                    }
                    break;

                case FieldType.Alpha:

                    /** Convesión de un campo alfa **/

                    if (format == FieldFormat.BinaryCodedDecimal)
                    {
                        if (length == FieldLength.Fixed)
                        {
                            string alpha = BitConverter.ToString(data.Take(size).ToArray()).Replace("-", "");

                            data = data.Skip(size).ToArray();

                            return new Field(id, alpha);
                        }
                        else
                        {
                            byte[] vli = data.Take(minSize - 1).ToArray();
                            int realSize = GetSize(vli, FieldFormat.BinaryCodedDecimal);
                            int nBytes = (realSize / 2) % 2 == 0 ? realSize / 2 : realSize / 2 + 1;
                            nBytes = nBytes == 0 ? nBytes + 1 : nBytes;
                            string alpha = BitConverter.ToString(data.Skip(minSize - 1).Take(nBytes).ToArray()).Replace("-", "").Substring(0, realSize);

                            data = data.Skip(minSize - 1 + nBytes).ToArray();

                            return new Field(id, alpha);
                        }
                    }
                    else if ((format & FieldFormat.Hexadecimal) == FieldFormat.Hexadecimal)
                    {
                        if (length == FieldLength.Fixed)
                        {
                            string alpha = Encoding.ASCII.GetString(data.Take(size).ToArray());

                            data = data.Skip(size).ToArray();

                            if (HasSpecial(alpha) || HasNumeric(alpha))
                                throw new FormatException("Los datos no contienen unicamente caracteres alfa.");

                            return new Field(id, alpha.Trim());
                        }
                        else
                        {
                            byte[] vli = data.Take(minSize - 1).ToArray();
                            int realSize = GetSize(vli, format);
                            string alpha = Encoding.ASCII.GetString(data.Skip(minSize - 1).Take(realSize).ToArray());

                            data = data.Skip(minSize - 1 + realSize).ToArray();

                            if (HasSpecial(alpha) || HasNumeric(alpha))
                                throw new FormatException("Los datos no contienen unicamente caracteres alfa.");

                            return new Field(id, alpha.Trim());
                        }
                    }
                    break;

                case FieldType.Special:

                    /** Convesión de un campo especial **/

                    if ((format & FieldFormat.Hexadecimal) == FieldFormat.Hexadecimal)
                    {
                        if (length == FieldLength.Fixed)
                        {
                            string special = Encoding.ASCII.GetString(data.Take(size).ToArray());

                            data = data.Skip(size).ToArray();

                            if (HasAlpha(special) || HasNumeric(special))
                                throw new FormatException("Los datos no contienen unicamente caracteres especiales.");

                            return new Field(id, special.Trim());
                        }
                        else
                        {
                            byte[] vli = data.Take(minSize - 1).ToArray();
                            int realSize = GetSize(vli, format);
                            string special = Encoding.ASCII.GetString(data.Skip(minSize - 1).Take(realSize).ToArray());

                            data = data.Skip(minSize - 1 + realSize).ToArray();

                            if (HasAlpha(special) || HasNumeric(special))
                                throw new FormatException("Los datos no contienen unicamente caracteres especiales.");

                            return new Field(id, special.Trim());
                        }
                    }
                    break;

                case FieldType.Binary:

                    /** Conversión a un campo de binario **/

                    if ((format & FieldFormat.Hexadecimal) != FieldFormat.Hexadecimal)
                        throw new ArgumentOutOfRangeException(nameof(format), "Los campos binarios unicamente se almacenan en formato hexadecimal.");

                    if (length == FieldLength.Fixed)
                    {
                        byte[] content = data.Take(size).ToArray();

                        data = data.Skip(size).ToArray();

                        var padding = content.Reverse().TakeWhile(b => b == 0).Count();

                        return new Field(id, content.Take(content.Length - padding));
                    }
                    else
                    {
                        byte[] vli = data.Take(minSize - 1).ToArray();
                        int realSize = GetSize(vli, format);
                        byte[] content = data.Skip(minSize - 1).Take(realSize).ToArray();

                        data = data.Skip(minSize - 1 + realSize).ToArray();

                        return new Field(id, content);
                    }

                case FieldType.Alpha | FieldType.Special:

                    /** Convesión de un campo alfa y especial **/

                    if ((format & FieldFormat.Hexadecimal) == FieldFormat.Hexadecimal)
                    {
                        if (length == FieldLength.Fixed)
                        {
                            string alpha = Encoding.ASCII.GetString(data.Take(size).ToArray());

                            data = data.Skip(size).ToArray();

                            if (HasNumeric(alpha))
                                throw new FormatException("Los datos no contienen unicamente caracteres alfa y especiales.");

                            return new Field(id, alpha.Trim());
                        }
                        else
                        {
                            byte[] vli = data.Take(minSize - 1).ToArray();
                            int realSize = GetSize(vli, format);
                            string alpha = Encoding.ASCII.GetString(data.Skip(minSize - 1).Take(realSize).ToArray());

                            data = data.Skip(minSize - 1 + realSize).ToArray();

                            if (HasNumeric(alpha))
                                throw new FormatException("Los datos no contienen unicamente caracteres alfa y especiales.");

                            return new Field(id, alpha);
                        }
                    }
                    break;

                case FieldType.Numeric | FieldType.Special:

                    /** Convesión de un campo numérico y especial **/

                    if ((format & FieldFormat.Hexadecimal) == FieldFormat.Hexadecimal)
                    {
                        if (length == FieldLength.Fixed)
                        {
                            string alpha = Encoding.ASCII.GetString(data.Take(size).ToArray());

                            data = data.Skip(size).ToArray();

                            if (HasAlpha(alpha))
                                throw new FormatException("Los datos no contienen unicamente caracteres especiales y numéricos.");

                            return new Field(id, alpha.Trim());
                        }
                        else
                        {
                            byte[] vli = data.Take(minSize - 1).ToArray();
                            int realSize = GetSize(vli, format);
                            string alpha = Encoding.ASCII.GetString(data.Skip(minSize - 1).Take(realSize).ToArray());

                            data = data.Skip(minSize - 1 + realSize).ToArray();

                            if (HasAlpha(alpha))
                                throw new FormatException("Los datos no contienen unicamente caracteres especiales y numéricos.");

                            return new Field(id, alpha);
                        }
                    }
                    break;

                case FieldType.Alpha | FieldType.Numeric:

                    /** Convesión de un campo alfanumérico **/

                    if (format == FieldFormat.BinaryCodedDecimal)
                    {
                        if (length == FieldLength.Fixed)
                        {
                            string alpha = BitConverter.ToString(data.Take(size).ToArray()).Replace("-", "");

                            data = data.Skip(size).ToArray();

                            return new Field(id, alpha.Trim());
                        }
                        else
                        {
                            byte[] vli = data.Take(minSize - 1).ToArray();
                            int realSize = GetSize(vli, FieldFormat.BinaryCodedDecimal);
                            int nBytes = (realSize / 2) % 2 == 0 ? realSize / 2 : realSize / 2 + 1;
                            nBytes = nBytes == 0 ? nBytes + 1 : nBytes;
                            string alpha = BitConverter.ToString(data.Skip(minSize - 1).Take(nBytes).ToArray()).Replace("-", "").Substring(0, realSize);

                            data = data.Skip(minSize - 1 + nBytes).ToArray();

                            return new Field(id, alpha);
                        }
                    }
                    else if ((format & FieldFormat.Hexadecimal) == FieldFormat.Hexadecimal)
                    {
                        if (length == FieldLength.Fixed)
                        {
                            string alpha = Encoding.ASCII.GetString(data.Take(size).ToArray());

                            data = data.Skip(size).ToArray();

                            if (HasSpecial(alpha))
                                throw new FormatException("Los datos no contienen unicamente caracteres alfa y numéricos.");

                            return new Field(id, alpha.Trim());
                        }
                        else
                        {
                            byte[] vli = data.Take(minSize - 1).ToArray();
                            int realSize = GetSize(vli, format);
                            string alpha = Encoding.ASCII.GetString(data.Skip(minSize - 1).Take(realSize).ToArray());

                            data = data.Skip(minSize - 1 + realSize).ToArray();

                            if (HasSpecial(alpha))
                                throw new FormatException("Los datos no contienen unicamente caracteres alfa y numéricos.");

                            return new Field(id, alpha);
                        }
                    }
                    break;

                case FieldType.Alpha | FieldType.Numeric | FieldType.Special:

                    /** Convesión de un campo alfanumérico y especial **/

                    if ((format & FieldFormat.Hexadecimal) == FieldFormat.Hexadecimal)
                    {
                        if (length == FieldLength.Fixed)
                        {
                            string alpha = Encoding.ASCII.GetString(data.Take(size).ToArray());

                            data = data.Skip(size).ToArray();

                            return new Field(id, alpha.Trim());
                        }
                        else
                        {
                            byte[] vli = data.Take(minSize - 1).ToArray();
                            int realSize = GetSize(vli, format);
                            string alpha = Encoding.ASCII.GetString(data.Skip(minSize - 1).Take(realSize).ToArray());

                            data = data.Skip(minSize - 1 + realSize).ToArray();

                            return new Field(id, alpha);
                        }
                    }
                    break;

                default:
                    break;
            }
            throw new ArgumentOutOfRangeException(nameof(type), "El tipo de campo no es valido para los mensajes ISO8583.");
        }

        /// <summary>
        /// Obtiene los bytes que representan al campo actual especificando el tipo y la longitud
        /// máxima o fija.
        /// </summary>
        /// <param name="size"> Longitud máxima o fija del campo. </param>
        /// <param name="type"> Tipo del campo a codificar. </param>
        /// <param name="length"> Tipo de longitud que maneja el campo. </param>
        /// <param name="format"> Formato del campo. </param>
        /// <param name="spaceChar">Caracter utilizado para reprensentar los espacios (default: ~).</param>
        /// <returns> Un vector de bytes que representan al campo. </returns>
        public byte[] Encode(int size, FieldType type, FieldLength length, FieldFormat format, Char spaceChar = '~')
        {
            int minSize = size;
            int maxSize = size;
            int realSize = Value.ToString()?.Length ?? 0;
            object value = Value;

            if (value == null)
                throw new InvalidOperationException("No se puede enviar campos nulos a través de mensajes ISO 8583, para ello no lo incluya en el mensaje.");

            switch (length)
            {
                case FieldLength.Fixed:
                    minSize = size;
                    break;

                case FieldLength.Lvar:
                    minSize = 2;
                    break;

                case FieldLength.Llvar:
                    minSize = (format & FieldFormat.BinaryCodedDecimal) == FieldFormat.BinaryCodedDecimal ? 2 : 3;
                    break;

                case FieldLength.Lllvar:
                    minSize = (format & FieldFormat.BinaryCodedDecimal) == FieldFormat.BinaryCodedDecimal ? 3 : 4;
                    break;

                default:
                    throw new ArgumentOutOfRangeException(nameof(length), "El tipo de longitud del campo no es valida para los mensajes ISO8583.");
            }

            switch (format)
            {
                case FieldFormat.Hexadecimal:
                    break;

                case FieldFormat.BinaryCodedDecimal:
                    if (type == FieldType.Special)
                        throw new ArgumentOutOfRangeException(nameof(format), "El formato no es compatible con el tipo especificado para los mensajes ISO8583.");
                    break;

                default:
                    throw new ArgumentOutOfRangeException(nameof(format), "El formato del campo no es valido para los mensajes ISO8583.");
            }

            switch (type)
            {
                case FieldType.Numeric:

                    /** Convesión de un campo numérico **/

                    if (format == FieldFormat.BinaryCodedDecimal)
                    {
                        if (length == FieldLength.Fixed)
                        {
                            List<byte> bytes = new List<byte>();
                            var content = value.ToString().PadLeft(size * 2, '0').Substring(0, size * 2);

                            for (int i = 0; i < content.Length; i += 2)
                                bytes.Add(byte.Parse(content.Substring(i, 2)));

                            return bytes.ToArray();
                        }
                        else
                        {
                            List<byte> bytes = new List<byte>();

                            var text = value.ToString();
                            int totalWidth = text.Length + (text.Length % 2);
                            var content = text.PadLeft(totalWidth, '0').Substring(
                                totalWidth > maxSize ? totalWidth - maxSize : 0,
                                totalWidth > maxSize ? maxSize : totalWidth);
                            var sizeVli = content.Length.ToString().PadLeft(minSize - 1, '0');

                            content = sizeVli + content;

                            for (int i = 0; i < content.Length; i += 2)
                                bytes.Add(byte.Parse(content.Substring(i, 2)));

                            return bytes.ToArray();
                        }
                    }
                    else if ((format & FieldFormat.Hexadecimal) == FieldFormat.Hexadecimal)
                    {
                        if (length == FieldLength.Fixed)
                        {
                        }
                        else
                        {
                        }
                    }

                    break;

                case FieldType.Alpha:

                    /** Convesión de un campo alfa **/

                    if (format == FieldFormat.BinaryCodedDecimal)
                    {
                        if (length == FieldLength.Fixed)
                        {
                            List<byte> bytes = new List<byte>();
                            var content = value.ToString().PadRight(size * 2, '0').Substring(0, size * 2);

                            for (int i = 0; i < content.Length; i += 2)
                                bytes.Add(byte.Parse(content.Substring(i, 2), NumberStyles.AllowHexSpecifier));

                            return bytes.ToArray();
                        }
                        else
                        {
                        }
                    }
                    else if ((format & FieldFormat.Hexadecimal) == FieldFormat.Hexadecimal)
                    {
                        if (length == FieldLength.Fixed)
                        {
                        }
                        else
                        {
                        }
                    }

                    break;

                case FieldType.Special:

                    /** Convesión de un campo especial **/

                    if ((format & FieldFormat.Hexadecimal) == FieldFormat.Hexadecimal)
                    {
                        if (length == FieldLength.Fixed)
                        {
                        }
                        else
                        {
                        }
                    }

                    break;

                case FieldType.Binary:

                    /** Conversión a un campo de binario **/

                    if ((format & FieldFormat.Hexadecimal) == FieldFormat.Hexadecimal)
                    {
                        if (length == FieldLength.Fixed)
                        {
                        }
                        else
                        {
                        }
                    }

                    break;

                case FieldType.Alpha | FieldType.Special:

                    /** Convesión de un campo alfa y especial **/

                    if ((format & FieldFormat.Hexadecimal) == FieldFormat.Hexadecimal)
                    {
                    }

                    break;

                case FieldType.Numeric | FieldType.Special:

                    /** Convesión de un campo numérico y especial **/

                    if ((format & FieldFormat.Hexadecimal) == FieldFormat.Hexadecimal)
                    {
                        if (length == FieldLength.Fixed)
                        {
                        }
                        else
                        {
                        }
                    }

                    break;

                case FieldType.Alpha | FieldType.Numeric:

                    /** Convesión de un campo alfanumérico **/

                    if (format == FieldFormat.BinaryCodedDecimal)
                    {
                        if (length == FieldLength.Fixed)
                        {
                            List<byte> bytes = new List<byte>();
                            var content = value.ToString().PadRight(size * 2, spaceChar).Substring(0, size * 2);

                            for (int i = 0; i < content.Length; i += 2)
                                bytes.Add(byte.Parse(content.Substring(i, 2), NumberStyles.AllowHexSpecifier));

                            return bytes.ToArray();
                        }
                        else
                        {
                        }
                    }
                    else if ((format & FieldFormat.Hexadecimal) == FieldFormat.Hexadecimal)
                    {
                        if (length == FieldLength.Fixed)
                        {
                        }
                        else
                        {
                        }
                    }

                    break;

                case FieldType.Alpha | FieldType.Numeric | FieldType.Special:

                    /** Convesión de un campo alfanumérico y especial **/

                    if ((format & FieldFormat.Hexadecimal) == FieldFormat.Hexadecimal)
                    {
                        if (length == FieldLength.Fixed)
                        {
                        }
                        else
                        {
                        }
                    }

                    break;

                default:
                    break;
            }
            throw new ArgumentOutOfRangeException(nameof(type), "El tipo de campo no es valido para los mensajes ISO8583.");
        }

        /// <summary>
        /// Obtiene el tamaño del campo a partir del formato que se esta .
        /// </summary>
        /// <param name="vli">Indicador de la longitud variable.</param>
        /// <param name="format">Formato del indicador.</param>
        /// <returns>Tamaño del campo.</returns>
        private static int GetSize(byte[] vli, FieldFormat format)
        {
            if ((format & FieldFormat.BinaryCodedDecimal) == FieldFormat.BinaryCodedDecimal)
                return Int32.Parse(BitConverter.ToString(vli).Replace("-", ""));
            return Int32.Parse(Encoding.ASCII.GetString(vli));
        }

        /// <summary>
        /// Valida si una cadena contiene caracteres alfa.
        /// </summary>
        /// <param name="text"> Cadena de caracteres a validar. </param>
        /// <returns> Un valor true si la cadena cumple la condición. </returns>
        private static bool HasAlpha(string text)
        {
            for (int i = 0; i < text.Length; i++)
                if ((text[i] > 39 || text[i] < 30) && text[i] < 128)
                    return true;
            return false;
        }

        /// <summary>
        /// Valida si una cadena contiene caracteres numéricos.
        /// </summary>
        /// <param name="text"> Cadena de caracteres a validar. </param>
        /// <returns> Un valor true si la cadena cumple la condición. </returns>
        private static bool HasNumeric(string text)
        {
            for (int i = 0; i < text.Length; i++)
                if (text[i] >= 30 && text[i] <= 39)
                    return true;
            return false;
        }

        /// <summary>
        /// Valida si una cadena contiene caracteres especiales.
        /// </summary>
        /// <param name="text">Cadena de caracteres a validar.</param>
        /// <returns>Un valor true si la cadena cumple la condición.</returns>
        private static bool HasSpecial(string text)
        {
            for (int i = 0; i < text.Length; i++)
                if (text[i] >= 128)
                    return true;
            return false;
        }
    }
}